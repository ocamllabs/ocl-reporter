Mirari takes a single configuration file and splits the lifecycle of a
Mirage application into three distinct segments:

* configuration: it scans the config file, checks for any missing OPAM
  dependencies, and installs them if missing.  It also looks for any
  filesystem directives and calls mir-crunch to generate the static ML
  files.  All of this is then glued together into an autogenerated
  main.ml which is the entry point for the application.

* build: it runs the OCaml build (via Vincent's obuild), and then
  issues any backend-specific commands (such as the specific link
  script for the Xen backend, or whatever else we dream up). For
  convenience, a symlink pointing to the compiled binary will be
  created in the current working directory.

* run: this is being implemented.  Running a Mirage application is
  quite stateful: in the case of Xen, we want to monitor the kernel,
  attach a console, and so on.  Similarly for UNIX, one can imagine
  the socket version opening up a control channel for Mirari to pass
  additionnal configuration directives, such as network interfaces.
  An in the kFreeBSD backend, this would be done via ioctls or other
  kernel/user interfaces.
